import numpy as np
import tcod

# def simplify_path(path):
#     # Simplify straight segments
#     new_path = [path[0]]
#     i = 1
#     while i < len(path):
#         start = len(new_path) - 1
#         # Find end of straight segment
#         while i < len(path) and (path[i][0] == new_path[-1][0] or path[i][1] == new_path[-1][1]):
#             new_path.append(path[i])
#             i += 1
#         if len(new_path) - start > 2:
#             # Keep only first and last
#             new_path = new_path[:start+1] + [new_path[-1]]
#         # If not, already added
#     # Now simplify diagonal segments
#     diag_segments = []
#     i = 1
#     while i < len(new_path):
#         if abs(new_path[i][0] - new_path[i-1][0]) == 1 and abs(new_path[i][1] - new_path[i-1][1]) == 1:
#             start = i - 1
#             i += 1
#             while i < len(new_path) and abs(new_path[i][0] - new_path[i-1][0]) == 1 and abs(new_path[i][1] - new_path[i-1][1]) == 1:
#                 i += 1
#             end = i - 1
#             if end - start > 1:  # more than 2 points
#                 diag_segments.append((start, end))
#         else:
#             i += 1
#     # Remove middle points of diag segments
#     to_keep = set()
#     for start, end in diag_segments:
#         to_keep.add(start)
#         to_keep.add(end)
#     simplified = []
#     for j in range(len(new_path)):
#         if j in to_keep or not any(start <= j <= end for start, end in diag_segments):
#             simplified.append(new_path[j])
#     return simplified



# Create a 20x20 grid, 1 = walkable, 0 = wall
grid = np.ones((5, 10), np.int8)

# Add some obstacles
grid[1:3, 1:5] = 0  # vertical wall
grid[4, 1:8] = 0  # horizontal wall
grid[1:4,8] = 0  # left wall
grid[2,5:7] = 0  # right wall

# Create the graph
# graph = tcod.path.SimpleGraph(cost=grid, cardinal=1, diagonal=2)

# Find the path from start to end
start_points=[(0,0)]
end_points=[(3,7)]
path = tcod.path.path2d(cost = grid, start_points=start_points, end_points=end_points, cardinal=10, diagonal=14)
print(grid)
print(path)
display_grid = grid.astype(str)
display_grid[tuple(np.array(path).T)] = '-'
display_grid[tuple(np.array(start_points).T)] = 'S'
display_grid[tuple(np.array(end_points).T)] = 'E'
print('with repeated direction instructions:')
print(display_grid)

path = path.tolist()

########## TESTING SIMPLIFY FUNCTION ##########

cardinal_path = [path[0]]
i = 1 #start with second waypoint

## deals with straight segments
while i < len(path) - 1:
    n_i = abs(path[i+1][0] - path[i-1][0]) #compares next and previous waypoints i
    n_j = abs(path[i+1][1] - path[i-1][1]) #compares next and previous waypoints j
    n_ij = n_i*n_j #if there is a change, n_ij is non-zero
    if not (n_ij == 0):
        cardinal_path.append(path[i])
    i += 1
cardinal_path.append(path[-1])

#deals with diagonal segments
# print(cardinal_path)

display_simple_grid = grid.astype(str)
display_simple_grid[tuple(np.array(cardinal_path).T)] = '-'
display_simple_grid[tuple(np.array(start_points).T)] = 'S'
display_simple_grid[tuple(np.array(end_points).T)] = 'E'
print('simplified cardinal instructions:')
print(display_simple_grid)


# print('Simplified path:')
# print(simplified)
# display_grid = grid.astype(str)
# display_grid[tuple(np.array(simplified).T)] = '-'
# display_grid[tuple(np.array(start_points).T)] = 'S'
# display_grid[tuple(np.array(end_points).T)] = 'E'
# print('Simplified path visualization:')
# print(display_grid)

